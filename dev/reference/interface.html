<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Algorithm interfaces · MathProgIncidence</title><meta name="title" content="Algorithm interfaces · MathProgIncidence"/><meta property="og:title" content="Algorithm interfaces · MathProgIncidence"/><meta property="twitter:title" content="Algorithm interfaces · MathProgIncidence"/><meta name="description" content="Documentation for MathProgIncidence."/><meta property="og:description" content="Documentation for MathProgIncidence."/><meta property="twitter:description" content="Documentation for MathProgIncidence."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">MathProgIncidence</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Introduction</a></li><li><a class="tocitem" href="../overview.html">Overview</a></li><li><a class="tocitem" href="../example.html">Simple Example</a></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="index.html">Reference Outline</a></li><li><a class="tocitem" href="get_equality.html">Identifying equality and inequality constraints</a></li><li><a class="tocitem" href="identify_variables.html">Identifying variables in constraints</a></li><li><a class="tocitem" href="incidence_graph.html">Incidence graph</a></li><li class="is-active"><a class="tocitem" href="interface.html">Algorithm interfaces</a></li><li><a class="tocitem" href="incidence_matrix.html">Incidence matrix</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href="interface.html">Algorithm interfaces</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="interface.html">Algorithm interfaces</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/lanl-ansi/MathProgIncidence.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/lanl-ansi/MathProgIncidence.jl/blob/main/docs/src/reference/interface.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Algorithm-interfaces"><a class="docs-heading-anchor" href="#Algorithm-interfaces">Algorithm interfaces</a><a id="Algorithm-interfaces-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithm-interfaces" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MathProgIncidence.IncidenceGraphInterface" href="#MathProgIncidence.IncidenceGraphInterface"><code>MathProgIncidence.IncidenceGraphInterface</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IncidenceGraphInterface(
    model;
    include_inequality = false,
    include_active_inequalities = false,
    tolerance = 0.0,
)</code></pre><p>A bipartite incidence graph of JuMP constraints and variables.</p><p>This is the primary data type accepted by the algorithms implemented in the remainder of this module. This type can be instantiated with a JuMP model or a tuple of <code>(graph, con_node_map, var_node_map)</code>, as returned by <a href="incidence_graph.html#MathProgIncidence.get_bipartite_incidence_graph"><code>get_bipartite_incidence_graph</code></a>. If a model is provided, optional arguments are the same as those provided to <code>get_bipartite_incidence_graph</code>.</p><p>Note that the fields of this struct are private, and may change behavior in a future release without warning.</p><p><strong>Example using only equality constraints</strong></p><pre><code class="language-julia hljs">using JuMP
import MathProgIncidence
m = Model()
@variable(m, v[1:3] &gt;= 0)
@constraint(m, eq_1, v[1] + v[3]^2 == 1.0)
@NLconstraint(m, eq_2, v[1]*v[2]^1.5 == 2.0)
graph = MathProgIncidence.IncidenceGraphInterface(m)</code></pre><p><strong>Example including active inequality constraints</strong></p><pre><code class="language-julia hljs">using JuMP
import Ipopt
import MathProgIncidence
m = Model(Ipopt.Optimizer)
@variable(m, v[1:3] &gt;= 0)
@NLconstraint(m, eq_1, v[1]*v[2]^1.5 == 2.0)
@constraint(m, ineq_1, v[1] + v[2] + v[3] &gt;= 7)
@objective(m, Min, v[1]^2 + 2*v[2]^2 + 3*v[3]^2)
optimize!(m)
graph = MathProgIncidence.IncidenceGraphInterface(
    m, include_active_inequalities = true, tolerance = 1e-6
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathProgIncidence.jl/blob/3c0b0237d58fe88cf3db3e77392e03ca21434c0f/src/interface.jl#L65-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MathProgIncidence.get_adjacent" href="#MathProgIncidence.get_adjacent"><code>MathProgIncidence.get_adjacent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_adjacent(
    igraph::IncidenceGraphInterface,
    constraint::JuMP.ConstriantRef,
)::Vector{JuMP.VariableRef}</code></pre><p>Return the variables adjacent to a constraint in an incidence graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathProgIncidence.jl/blob/3c0b0237d58fe88cf3db3e77392e03ca21434c0f/src/interface.jl#L150-L158">source</a></section><section><div><pre><code class="language-julia hljs">get_adjacent(
    igraph::IncidenceGraphInterface,
    variable::JuMP.VariableRef,
)::Vector{JuMP.ConstraintRef}</code></pre><p>Return the constraints adjacent to a variable in an incidence graph.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using JuMP

julia&gt; import MathProgIncidence

julia&gt; m = Model();

julia&gt; @variable(m, v[1:3]);

julia&gt; @constraint(m, eq_1, v[1] + v[3] == 1);

julia&gt; @NLconstraint(m, eq_2, v[1]*v[2]^3 == 2);

julia&gt; igraph = MathProgIncidence.IncidenceGraphInterface(m);

julia&gt; adj_cons = MathProgIncidence.get_adjacent(igraph, v[1]);

julia&gt; display(adj_cons)
2-element Vector{ConstraintRef}:
 eq_1 : v[1] + v[3] = 1.0
 v[1] * v[2] ^ 3.0 - 2.0 = 0
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathProgIncidence.jl/blob/3c0b0237d58fe88cf3db3e77392e03ca21434c0f/src/interface.jl#L169-L202">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MathProgIncidence.maximum_matching" href="#MathProgIncidence.maximum_matching"><code>MathProgIncidence.maximum_matching</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">maximum_matching(igraph::IncidenceGraphInterface)::Dict</code></pre><p>Compute a maximum matching of variables and constraints in the incidence graph.</p><p>The returned <code>Dict</code> maps JuMP <code>ConstraintRef</code>s to their matched <code>VariableRef</code>s.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using JuMP

julia&gt; import MathProgIncidence

julia&gt; m = Model();

julia&gt; @variable(m, v[1:3]);

julia&gt; @constraint(m, eq_1, v[1] + v[3] == 1);

julia&gt; @NLconstraint(m, eq_2, v[1]*v[2]^3 == 2);

julia&gt; igraph = MathProgIncidence.IncidenceGraphInterface(m);

julia&gt; matching = MathProgIncidence.maximum_matching(igraph);

julia&gt; display(matching)
Dict{ConstraintRef, VariableRef} with 2 entries:
  v[1] * v[2] ^ 3.0 - 2.0 = 0 =&gt; v[2]
  eq_1 : v[1] + v[3] = 1.0 =&gt; v[1]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathProgIncidence.jl/blob/3c0b0237d58fe88cf3db3e77392e03ca21434c0f/src/interface.jl#L213-L245">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MathProgIncidence.dulmage_mendelsohn" href="#MathProgIncidence.dulmage_mendelsohn"><code>MathProgIncidence.dulmage_mendelsohn</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dulmage_mendelsohn(igraph::IncidenceGraphInterface)</code></pre><p>Return the Dulmage-Mendelsohn partition of variables and constraints in an incidence graph.</p><p>The returned type is a <code>Tuple</code> of two <code>NamedTuple</code>s, <code>(con_dmp, var_dmp)</code>. These <code>NamedTuple</code>s have the following fields:</p><p><code>con_dmp</code>:</p><ul><li><code>underconstrained</code> – The constraints matched with variables that <em>can possibly be</em> unmatched in a maximum cardinality matching</li><li><code>square</code> – The constraints that cannot possibly be unmatched in a maximum matching</li><li><code>overconstrained</code> – The constraints that are matched, but <em>can possibly be</em> unmatched in a maximum matching</li><li><code>unmatched</code> – The constraints that are not matched in the maximum matching that was found</li></ul><p><code>var_dmp</code>:</p><ul><li><code>unmatched</code> – The variables that are not matched in the maximum matching that was found</li><li><code>underconstrained</code> – The variables that <em>can possibly be</em> unmatched in a maximum matching</li><li><code>square</code> – The variables that cannot possibly be unmatched in a maximum matching</li><li><code>overconstrained</code> – The variables matched with constraints that <em>can possibly be</em> unmatched in a maximum cardinality matching</li></ul><p>The Dulmage-Mendelsohn partition groups nodes in a bipartite graph into three unique subsets. In the application to constraints and variables, these may be thought of as:</p><ul><li>the &quot;overconstrained subsystem&quot;, which has more constraints than variables,</li><li>the &quot;underconstrained subsystem&quot;, which has more variables than constraints,</li><li>and the &quot;square subsystem&quot;, which has the same number of variables as constraints</li></ul><p>In the <code>NamedTuple</code>s returned by this function, the constraints in the overconstrained subsystem are split into <code>overconstrained</code> and <code>unmatched</code>, while the variables in the underconstrained subsystem are split into <code>underconstrained</code> and <code>unmatched</code>. This is because it is useful to explicitly check whether there are any unmatched variables and constraints, and also useful to recover the maximum matching by <code>zip</code>-ing corresponding variables and constraints.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using JuMP

julia&gt; import MathProgIncidence

julia&gt; m = Model();

julia&gt; @variable(m, v[1:4]);

julia&gt; @constraint(m, eq_1, v[1] + v[3] == 1);

julia&gt; @NLconstraint(m, eq_2, v[1]*v[2]^3 == 2);

julia&gt; @constraint(m, eq_3, v[4]^2 == 3);

julia&gt; igraph = MathProgIncidence.IncidenceGraphInterface(m);

julia&gt; con_dmp, var_dmp = MathProgIncidence.dulmage_mendelsohn(igraph);

julia&gt; # Assert that there are no unmatched constraints

julia&gt; @assert isempty(con_dmp.unmatched);

julia&gt; display(var_dmp.unmatched)
1-element Vector{VariableRef}:
 v[3]

julia&gt; display(var_dmp.underconstrained)
2-element Vector{VariableRef}:
 v[1]
 v[2]

julia&gt; display(con_dmp.underconstrained)
2-element Vector{ConstraintRef}:
 eq_1 : v[1] + v[3] = 1.0
 v[1] * v[2] ^ 3.0 - 2.0 = 0
 
julia&gt; display(var_dmp.square)
1-element Vector{VariableRef}:
 v[4]

julia&gt; display(con_dmp.square)
1-element Vector{ConstraintRef}:
 eq_3 : v[4]² = 3.0

julia&gt; # As there are no unmatched constraints, the overconstrained subsystem is empty</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathProgIncidence.jl/blob/3c0b0237d58fe88cf3db3e77392e03ca21434c0f/src/interface.jl#L287-L381">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MathProgIncidence.connected_components" href="#MathProgIncidence.connected_components"><code>MathProgIncidence.connected_components</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">connected_components(igraph::IncidenceGraphInterface)</code></pre><p>Return the connected components of a bipartite incidence graph of constraints and variables.</p><p>The connected components are returned as two vector-of-vectors, containing the variables in each connected component and the constraints in each connected component. Note that the input graph is undirected, so there is no distinction between strongly and weakly connected components.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using JuMP

julia&gt; import MathProgIncidence

julia&gt; m = Model();

julia&gt; @variable(m, x[1:2] &gt;= 0);

julia&gt; @constraint(m, eq1, x[1] == 1);

julia&gt; @constraint(m, eq2, x[2]^2 == 2);

julia&gt; igraph = MathProgIncidence.IncidenceGraphInterface(m);

julia&gt; con_comps, var_comps = MathProgIncidence.connected_components(igraph);

julia&gt; con_comps
2-element Vector{Vector{ConstraintRef}}:
 [eq1 : x[1] = 1]
 [eq2 : x[2]² = 2]

julia&gt; var_comps
2-element Vector{Vector{VariableRef}}:
 [x[1]]
 [x[2]]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathProgIncidence.jl/blob/3c0b0237d58fe88cf3db3e77392e03ca21434c0f/src/interface.jl#L414-L454">source</a></section><section><div><pre><code class="language-julia hljs">connected_components(constraints, variables)</code></pre><p>Return the connected components of a bipartite incidence graph of constraints and variables.</p><p>The method that accepts constraints and variables directly is convenient for working with the output of the Dulmage-Mendelsohn partition. It is often used to decompose and help debug the over and under-constrained subsystems.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using JuMP

julia&gt; import MathProgIncidence

julia&gt; m = Model();

julia&gt; @variable(m, x[1:4] &gt;= 0);

julia&gt; @constraint(m, eq1, x[1] + x[3] == 7);

julia&gt; @constraint(m, eq2, x[2]^2 + x[4]^2 == 1);

julia&gt; igraph = MathProgIncidence.IncidenceGraphInterface(m);

julia&gt; con_dmp, var_dmp = MathProgIncidence.dulmage_mendelsohn(igraph);

julia&gt; uc_con = con_dmp.underconstrained;

julia&gt; uc_var = [var_dmp.unmatched..., var_dmp.underconstrained...];

julia&gt; con_comps, var_comps = MathProgIncidence.connected_components(uc_con, uc_var);

julia&gt; con_comps
2-element Vector{Vector{ConstraintRef}}:
 [eq1 : x[1] + x[3] = 7]
 [eq2 : x[2]² + x[4]² = 1]

julia&gt; var_comps
2-element Vector{Vector{VariableRef}}:
 [x[3], x[1]]
 [x[4], x[2]]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/MathProgIncidence.jl/blob/3c0b0237d58fe88cf3db3e77392e03ca21434c0f/src/interface.jl#L467-L512">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="incidence_graph.html">« Incidence graph</a><a class="docs-footer-nextpage" href="incidence_matrix.html">Incidence matrix »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.2 on <span class="colophon-date" title="Sunday 19 November 2023 23:15">Sunday 19 November 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
